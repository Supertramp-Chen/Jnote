# web前后端基础架构原理

## 计算机网络是如何工作的

### 在网页中敲下命令按下回车的瞬间到另外一个页面成功加载完成 发生了什么


#### 数据如何被发送和接受


##### 网络、主机、ip地址

        一个计算机网络彼此有很多台计算机彼此之间用网线连接起来，自己有一个ip地址（外网ip）


        在打开网页的时候这个世界上一定有一个地方在处理你的请求

        HOST主机:世界上有很多彼此相连的计算机(想象为彼此用网线连接起来)
            每个主机会有一个地址
            在itv4的世界里是32位的地址（4个byte）4个字节用点连接起来就能得到ip地址 115.118.112.3

            地址可以唯一定位到一台计算机

            一个byte（-128——127）即不能超过255

            32位最多存42亿个数字（42亿个ip），不够用 即有了ipv6 128位（可以为地球上的每一粒沙子都分配地址）


##### ip地址很难记住 即需要DNS(domain name service)域名服务

        按下回车后，需要知道淘宝的ip地址 就向DNS请求查询 taobao.com
            域名是ip的别称
        DNS会返回给它一个ip地址



        如果本地已经保存了从taobao.com到ip地址的映射 就不要请求DNS（费时间）

            用本地的东西把域名服务覆盖掉
            在hosts里面 把一个ip地址指向一个域名之后，默认情况下就不会问DNS

            hosts可以强制让某一个域名跳转到那里去
                映射过后该域名就代表其ip


    按下回车的瞬间，你的游览器向远端的某个主机发送了一个请求

##### 端口port


    :区分域名和端口


    从网线上传输的数据怎么知道该数据是归属于哪个应用程序

    网线只有一根

    电脑上有很多港口（最多65536个港口）

    传输的数据 每个数据的数据包里都指定了是哪个港口




    用手机访问淘宝，某一处地方有个主机处理你的请求

    是在和这个主机的哪一个端口通讯


##### TCP、HTTP

    默认端口

        http协议的默认端口是 80
        https—— 443

        http://taobao.com等价于http://taobao.com:80 默认是访问80端口

        端口指定了你通讯的主机上的归属地



    最基本的通讯协议

        TCP传输控制协议 transport controy protocol 基于流的协议 （全双工协议 —— 电话，半双工协议 —— 对讲机）
        UDP一般不用

        当请求一些数据的时候 本地的某个端口就向远程的一个服务器的指定的端口开辟一条双向的高速公路（TCP） 跑的是数据

            双方都可以同时的发送和接受数据


        TCP协议只是规定了数据是如何组装起来的（字节如何发送，如何组装，字节流在网络上如何发送和接受）




    TCP协议之上有个HTTP协议（hyper text transport p，超文本传输协议，文本就是TCP定义的一个个的字节） 定义文本之外的东西如何传输

        按下回车的瞬间 游览器就通过你的主机向淘宝的ip地址 发出了一个数据请求(HTTP request)

        主机接受到你的请求后决定发送一个HTTP response


        你发送一堆字节过去，它回复一堆字节回来



#### 数据如何被游览器处理

    发送的字节流如何变成别的东西、游览器如何工作
    网络上传输的只是字节流

    假设你向豆瓣发送了一个http请求
    
    豆瓣回应了你一个http回应
    
    （HTTP 200 OK .... HEADERS \n\n\n <!doctype html>......
        响应体（可以是文本 也可以是二进制数据[图片、声音、下载的文件]））
      
    200 OK代表状态码
      HTTP 200 OK .... HEADERS HTTP响应头
        html定义这个页面如何被渲染

    现在游览器决定如何去解析http回应

     <!doctype html><html
      html定义这个页面如何被渲染（hyper text markup language 超文本标记语言）
      游览器看到一个标签开始就知道其是个文档树会把它解析为一颗html树，决定它如何被解释

      html规定了很多东西

        css告诉游览器当前这个页面应该如何被渲染
        一个一个的解析标签

        循环往复，发送请求得到回应，直到all things做完

        刚开始发送请求，拿到响应，然后游览器慢慢的解析它，做完all thing后就得到页面

        来一点相应文本就解析一点



#### java程序发出第一个HTTP请求


    发出去的all请求都是被代码所规定的，发出去的请求本质上都是程序的一堆代码执行的逻辑，按照确定的协议构造成一个个的字节流

    所以在游览器里能做的东西 在其他程序里也能做（只要遵循http协议）
    远程的host接受和发出的只是一堆数据

    用程序主动发起这样的过程


    使用一个库之前了解这个库的基本原理


    evaluate 进行表达式求值

##### 同步与异步加载（有些数据拿不到）

    当游览器请求数据的时候，服务器把整个html包含all数据返回给游览器



    服务器端返回部分数据，使用AJAX异步加载

        当游览器向后端发起请求的时候，拿到的页面里面可能只有部分数据，并没有看见的丰富的数据

        被页面上某些元素所动态加载出来的（eg一段代码js，额外的发起一个请求）
        第一次服务器返回给你的数据里只有简单的<html>代码里面有js，
            游览器解析js后再次发起请求（AJAX异步加载）返回的这段数据可以被js处理 js把其嵌到页面上

        or当你点击页面上的按钮，发出额外的请求然后把拿到的响应继续渲染到这个页面上


    游览器能做到的，代码也能做到（缺少一些东西）


# java实现http请求

    jdk11之前 使用内置的 Java 类HttpUrlConnection

    HttpUrlConnection类无需使用第三方库，需要的类皆在java.net
    
    缺点
        代码可能比其他 HTTP 库更麻烦，并且它不提供更高级的功能，例如用于添加标头或身份验证的专用方法

