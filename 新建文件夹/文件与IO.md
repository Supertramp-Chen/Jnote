# 文件和IO

    第三发库、接口...操作都是在内存上的操作，但没有把数据保存在磁盘上过


    CPU（大脑，进行一切运算） 内存（存数据，断电丢失） 硬盘（存数据，容量大，断电不丢失）

    内存比CPU慢，硬盘比内存慢


    CPU

        eg 3GHZ

        HZ —— s的倒数

        G —— 10亿

        每秒可以运行30亿调指令（1+1每条最简单的操作大约需要花掉一条指令）
        一条指令0.3ns


    CPU好比是一个人要吃饭，内存是个碗 
    CPU能直接把碗里的东西吃下
    但是all东西还是放在锅里的   

    硬盘就是CPU在吃数据的时候存东西的一个锅子，需要先把饭盛到碗里面



# 文件的本质

    操作系统存在的意义

        它能让它上面的程序拿到底层的数据

        APP —— C://mpa（你只要给他一串字符串 操作系统就会给你一个文件）




    文件的本质就是一段字节流（字节如细胞 文件如一个生命，但其细胞是有序的）

        文本文件（txt/代码/HTML..）
        二进制文件

        一个文件展示的是什么样子取决于这个程序把它展示成什么样，程序字节决定怎么去解释这些数据

        本质是一堆字节，但是编辑器会把这一堆字节 按照ASCII去处理

        每个程序负责解释文件中的字节流


        二进制文件（有大量的乱码，没有对应的字符）

        文件本质上就是这样没有规律的字节


        读是一个字节一个字节的读
        写也是一个字节一个字节的写   
        和HTTP相似  IO


# IO

    不是对文件系统绝对熟悉，使用绝对路径

    io是站在程序的角度看

    读进来一个换行符的时候 把它输出的时候 会自动把输出的位置向下移一行

[java IO实例](IO)


    输入可以来源于文件or网络

# 文件类file

    File

        代表一个文件对象?
        代表一个文件路径?
        代表一个文件的内容?

    java.io.File
    File代表文件路径 和String没有本质上的区别


        file中有各种方法

    

# 绝对、相对路径

    绝对路径

        windows —— C盘orD盘开头
        Unix    —— / 开头    
        可以直接定位到一个东西
        XXX的父亲


    相对路径w

        只有在相对一个路径的时候才有效
        父亲（只有在家里叫父亲才能对应到一个人，在外面随便叫则不行）

        相对路径相对的是JVM进程的当前工作目录


    可以通过一个父亲目录以及子目录的名字构造出一个相应的文件路径

    ```java

            File home = new File("C:\\Users\\86183\\Desktop\\新建文件夹 (2)");
            File song = new File("home","新建文件夹");
    
    ```



    File.getCanonicalPath()归一化，整齐化
    ././././..

# java的NIO

    java7以后  

    如果一个名字指的是一个类 其后加一个s 就代表和这个类相应的一堆工具方法

    Files里面的方法

    NIO的Path - 就是旧版本的File




    经典的IO模型是基于流的

        优点

            直观 易理解 方便抽象（一段代码可以做很多事）

        缺点

            慢（必须一个字节一个字节的来）


    NIO中数据模式是基于 块

        块和块之间是没有顺序的


    IO设备太慢了 使得CPU需要等待太久

        缓冲（buffer ，cache）（BufferedReader一次性读很多东西到缓冲区，BufferedWriter一次性写很多东西到缓冲区）可以自己用编程实现

            如CPU要往硬盘上写东西

                1. 一个字节一个字节的写（写一个字节就要等3万个周期）

                2.攒一堆一块写（先写入到缓冲区，攒到一定量后一次性写到硬盘）

            CPU中的L1cache L2cache这些缓存只是CPU和内存打交道时存储指令等的

            进行IO的时候 缓存区是放在内存中的（Buffer）


        并发（多线程）

            CPU在等待IO的时候 CPU再去做别的事情



    Linux系统中换行符只有/n没有/r，所以Linux的文件原封不动的拿到windows上可能会出现错误 Windows可能识别不了




# 不需要重复发明轮子