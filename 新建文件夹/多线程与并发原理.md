# why

    CPU很快 （执行一个a+1操作需要先从内存中读取数据 操作完再把数据放回去）在等待其他的时候能做一些别的事情

    现代CPU是多核的，同时可以做很多事情（发热量制约CPU频率的上升）

    java的执行模型是 同步 阻塞的block(线程的执行流会停留在这里，等待方法执行完)

    默认情况下只有一个线程
        线程 ：可以按照这个代码标准去挨个执行它的一个工人

        处理问题自然

        具有严重性能问题

# JVM

    两部分构成 
    
        方法栈(a() - b() - main())

        堆


    
# Thread
    
    Java中只有这么⼀种东⻄代表线程
    
    start⽅法才能并发执⾏！（run则是要等它把事情做完才能执行下一个）

    每多开⼀个线程，就多⼀个执⾏流（多了一个线程就多了一个方法栈（b()里面的thread.star（） —— run））可以一起干活

    ⽅法栈(局部变量)是线程私有的

    静态变量/类变量是被所有线程共享的

[代码图](png/thread.png)





# 线程难的本质原因

    你要看着同⼀份代码，
    想象不同的⼈在疯狂地以乱序执⾏它(在某个时刻 你并不知道谁在执行它)

        对一个单核CPU来说，线程1开始做一件事情 但还是CPU的事情 某一个时刻线程1占据CPU做一件事情
        操作系统能决定某一个线程占用多少时间，一旦时间到了CPU强制它终止，把它放一边 开始执行第二个线程  

        工人自己的事情可以随时被CPU打乱
[示意图](png/process.png)


    原子操作
        多线程领域 一个事情某一个时刻只能被一个线程做

    多线程中一个线程执行过程中 可能中途就被CPU终止 进而执行另外一个线程2，thread2执行完后 返而执行刚才执行到一半的Thead1

    多个线程 同时访问一个共享变量的时候 由于该变量不是原子的 以至于其过程是乱序的

[代码图](png/thread乱序.png)
[示意图](png/线程于CPU.png)







# 演示多线程带来的性能提升

一个抽象的任务两种类型

    CPU密集型(CPU intense) 不适合多线程

        如解包一个zip文件 不停的算东西，CPU要不停的进行运算

        多线程提升有限


    IO密集型应⽤极其有⽤

        文件操作（从网上下载一个东西保存到本地，网络传输的时间比CPU的时间慢的多）等待网络请求的时候CPU可以做很多事情


        ⽹络IO（通常包括数据库）
[示意图](png/网络IO.png)
        ⽂件IO

• 对于CPU密集型应⽤稍有折扣
• 性能提升的上限在哪⾥？
• 单核CPU 100%
• 多核CPU N*100%


# 发现线程卡住时

    命令行

        jps
        显示当前在运行的alljava进程
        拿到进程id

        jstack id
        检查进程卡在哪里

昂贵的线程
• 能不能使⽤线程达到⽆穷⽆尽的性能提升?
• ⼗个⼥⼈⼀个⽉能⽣⼀个孩⼦么？
• 线程的昂贵性在于
• 第⼀，CPU切换上下⽂很慢
• 第⼆，线程需要占⽤内存等系统资源
• 如果你的应⽤⼀天才⼏个⽤户
• new Thread().start()
• 如果你的应⽤负载很⾼
• 使⽤线程池:JUC包


线程安全
• 你享⽤了多线程的便利，就要付出代价
• 原⼦性
• 共享变量
• 默认的实现⼏乎都不是线程安全的

线程不安全的表现
• 数据错误
• i++
• if-then-do


死锁


著名的HashMap的死循环问题
• 写⼀段代码来重现死锁
• 预防死锁产⽣的原则：
• 所有的线程都按照相同的顺序获得资源的锁
• 死锁问题的排查
• 多线程的经典问题：哲学家⽤餐


线程安全
• 实现线程安全的基本⼿段
• 不可变类
• Integer/String/..


线程安全
• 实现线程安全的基本⼿段
• synchronized同步块
• 同步块同步了什么东⻄？
• synchronized(⼀个对象) 把这个对象当成锁
• Static synchronized⽅法 把Class对象当成锁
• 实例的synchronnized⽅法把该实例当成锁
• Collections.synchronized

实现线程安全的基本⼿段
• JUC包
• AtomicInteger/...
• ConcurrentHashMap
• 任何使⽤HashMap有线程安全问题的地⽅
• 都⽆脑地使⽤ConcurrentHashMap替换即可。
• ReentrantLock


Object类⾥的线程⽅法
• 线程的历史
• Java从⼀开始就把线程作为语⾔特性，提供语⾔级的⽀持
• 为什么Java中的所有对象都可以成为锁？
• Object.wait()/notify()/notifyAll()⽅法
• 线程的状态与线程调度
• 【扩展】为什么说Java的线程


多线程的经典问题
⽣产者/消费者模型
• 使⽤三种⽅法来解决它
• wait/notify/notifyAll
• Lock/Condition
• BlockingQueue


线程池与Callable/Future
• 什么是线程池
• 线程是昂贵的（Java线程模型的缺陷）
• 线程池是预先定义好的若⼲个线程
• Java中的线程池
• Callable/Future
• 类⽐Runnable，Callable可以返回值，抛出异常
• Future代表⼀个“未来才会返回的结果”
• 实战：多线程的WordCount