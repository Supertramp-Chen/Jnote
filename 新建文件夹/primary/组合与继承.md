# 什么是继承  

    复用父类的代码

    程序员的宿命：复制&粘贴

    真的只能这样么？

    DRY(Donot Repeat Yourself)

    事不过三，三则重构

    继承的本质是 提炼出公⽤代码，避免重复

    举个栗⼦



# Java的继承体系

    单根继承

    不声明继承任何东西，它都隐式的继承了Object类（equals，toString）

    == 判断两个对象地址是否一样
    equals判断两个对象内容是不是一样

    单根继承有什么好处？

        保证all对象都拥有某个行为，all对象都继承Objec

    对⽐C++的多重继承
    Object类有哪些需要了解的⽅法？

    equals()

        == 判断两个对象地址是否一样
        equals判断两个对象内容是不是一样

    toString()

        对一个对象提供一个字符串的表示

        创建一个对象，并把它打印出来
        每当打印字符串的时候 都会调用这个对象的toSting方法

        或者使用 字符串 +


# 类的结构与初始化顺序


    ⼦类拥有⽗类的⼀切数据和⾏为

        一个对象继承了其他对象，都会被包含在自己的对象里面

```java
    class A {
        int age;
        //不声明构造器的情况下，默认生成的构造器
        public A() {

        }
    }
    class B extends A {
        //默认情况下，编译器偷偷写的
        public B(){
            super();
        }
    }
```

    A extends B extends C

    C对象先被创建出来，然后是B 然后是A

    ⽗类先于⼦类进行初始化

    必须拥有匹配的构造器

    super关键字

[将公用代码抽取到父类中](https://github.com/hcsp/refactor-to-base-class/pull/279)

# 实例⽅法的Override


    ⼜称为覆盖/重写

    永远使⽤@Override注解来防⼿残

        覆盖标志，使得编译器帮助检查

    举个栗⼦

    String.equals


# 实战：模板⽅法


    提供⼀个“模板”，用户实现可以覆盖模板的全部或者部分


# 向上/向下转型


    ⼀个⼦类类型的对象永远是⼀个⽗类类型的对象

        正如⼀只猫同时也是⼀只动物，同时也是⼀个对象

        instanceof判断类型 判断一个对象是不是指定类的实例/对象

        null instanceof ? == false


    因此，当需要⼀个⽗类型时，总可以传递⼀个⼦类型

    但是，有的时候你必须进⾏⼀些转型

        转型是不安全的

        失败了怎么办？




# super关键字


    调⽤⽗类的⽅法（包括构造函数）


# final关键字


    final声明变量，变量成为不可变的（必须初始化）

    final声明对象，该对象只能指向它，地址不可改变，但对象中的内容是可改变的 

        局部变量/⽅法参数

        成员变量

        常量与单例

    final在⽅法上的声明：禁⽌继承/覆盖/重写此⽅法

    final在类声明上的使⽤：禁⽌继承此类

        继承提供了灵活性，也埋下了隐患

        栗⼦：为什么String/Integer等类是final的？

    

# 组合


    继承：is-a （是一个父类）

    组合：has-a （有的关系）

        复用代码

    但是实际中，⼆者的界限有时候很难区分

    栗⼦1：CountingSet

    栗⼦2：完全不使⽤继承


