# 什么是对象

    对象就是数据和⾏为的集合（主观能动性）

    ⼀切⽤new运算符创建出来的都是对象
        new Object()
        特例：new Integer()/new String()
        特例：new Object[]

        Integer a = 1
            从原生类型自动装箱，自动拆箱
            jvm偷偷帮你创造对象，也是对象
        String S = ""
            字符串已经事先在内存（常量池）中放好了
            等价于 String S = new String("")
            对象在内存中的某个区域已经帮你创建好了

        
        原生类型
        
        引用类型
            有一个类



# 对象是由什么组成的

    所有的对象都在堆上分配
    每个对象都包含⾃⼰的数据（成员变量）
        原⽣类型的成员（实打实存放着）
        引⽤类型的成员（只是个地址）



# 对象初始化构造过程

    新建对象的唯⼀途径

        在堆上分配空间
    
        执⾏必要的初始化⼯作（不赋值的时候 成员会初始化为默认值，0，null）
    
        执⾏构造器函数

    如果没有任何构造器，编译器会偷偷摸摸帮你⽣成⼀个

来，我们⽤断点调试⼤法看看构造函数调⽤的过程



# 对象的⽅法

    数据是“有什么”

    ⽅法是“做什么


# ⽅法的重载(overload)

重载（overload）与重写/覆盖（override）

    如何区分同名的不同重载⽅法？
        根据类型
        那隐式转换呢？(自动装箱、拆箱 int - Integer)
            类型最匹配优先(如果能匹配多个呢？null)


    java中每个对象都有类型，类型树的最高处为object

[示意图](../png/重载.png)

```java
    Number obj = 1;
    cat.f(obj);//会按照变量的类型去匹配一个实际的最接近的方法

    cat.f(null)//如果没有类型
    void f(int i){}
    void f(Integer i){}
    void f(Number i){}
    void f(Object i){}
```


    不能仅仅重载返回值
        但是在JVM中允许


# 如何为⽅法提供默认值

    没办法
    但是你可以通过重载曲线救国
        重载方式 在一个方法里调用别的方法



# 构造器的重载

    this()
[示意图](../png/构造器相互调用.png)

    实例：HashMap的构造器重载


# 对象的初始化

必要的初始化⼯作

    静态成员的初始化，静态初始化块（先于all对象发生）
    
    成员的初始化,初始化块


[示意图](../png/顺序.png)

继续断点调试⼤法检查初始化顺序



# 对象的⽣命周期


    如果⼀直新建对象，内存会不会爆？
        可能不会

    那对象的内存什么时候被回收？
        谁也不知道

    对象的内存如何被回收？
        不⽤管，垃圾回收器帮你⼲

    JVM怎么知道哪个对象没有被⽤到？
        通过引⽤链（GC Roots）

        预定了一些GC的根，这些根能达到的一切东西都不是垃圾，除此之外皆为垃圾

        GC Roots 开始延引用链 所有可达的引用、数据 都是活对象，除此为死对象

        死对象什么时候被回收由JVM垃圾回收器自己决定

[示意图](../png/GC%20roots.png)


        不可达的对象
        GC算法 垃圾回收算法 不仅仅删除，还可能压缩、规整到一切


# 数组——特殊的对象

数组类是什么？为什么我从来没有⻅过？
JVM为数组提供了特殊的处理⽅法
数组只有两个操作：[]与length
的⻓度不可变