最大程度实现灵活性和复用代码


# Abstract

    把一些类的重要代码抽取出来变成个骨架
    Abstarct封装一个功能的股价

    具体的类可以覆盖实现的方法


# 问题：如何禁⽌默认实现？
  
    父类不提供默认的实现
    要求子类一定要覆盖

        抛出异常
            运行时的，编译没报错

        抽象化
        抽象类
        接⼝


# 抽象类

    可以声明一个还没实现的方法 强迫子类都要去实现它 

    不可实例化
        抽象方法没有方法体
    
    可以实例化的东⻄⼀定要补全所有的⽅法体。
    
    可以包含抽象⽅法 - ⾮private/static
        抽象方法的目的就是让人去继承的，继承多态只发生在实例方法中

    可以包含普通类的任何东⻄



# 接⼝

    把抽象类all方法体都去掉

    接⼝部分的实现了多继承
    接⼝不是类
    接⼝的扩展
    接⼝只代表⼀种功能
    ⼀个类只能继承⼀个类，但是却能实现若⼲的接⼝

    implement 拥有某种功能
    extends 是一个什么
    一个东西只能是一个东西，但它可以有很多的功能

    当你只描述一种功能的时候用接口
    需要提供一些实现的时候，如模板，有方法体，使用抽象类 复用代码



# 接⼝可以包含什么

    实现一个接口要实现其all方法 or定义为抽象类

    若⼲个⽅法（默认public）

    若⼲个常量（默认public static final）
        对于这样的常量 命名约定all大写

    extends 接⼝


    默认⽅法

        不破坏向后兼容性的添加方法

        Since Java 8 之后可以有方法体

        是⼀种妥协的产物

        向后兼容性
        一旦接口成型后不能再增加方法，会导致之前实现这个接口的类报错（类必须实现接口中all方法）

        当后期想加入一个方法的时候
        default 默认方法，替这个方法提供一个默认实现，使得之前没有实现这个方法的类 也能毫无困难的正常工作  

        又为接口增加新的功能，又没有破坏向后兼容性


[接口变更示意图](../png/接口变更.png)      

引入了新的问题c++中二义性

[二义性示意图](../png/二义性.png)

        可以⽤来实现mixin
    
        菱形继承


# 接口、抽象类的差别

    同

        抽象 不可实例化
        可包含抽象方法（无方法体，非static/private/final）

    不同

        抽象类是类 可包含类的一切东西

        接口只能包含受限的成员（p s f）和方法（p d）

        抽象类只能单继承

        接口可以多继承，甚至继承多次


# 接⼝实战

    最大程度灵活性和复用

    要实现一个接口 可以先查找它有没有默认实现（这样就不用全部实现）

    Comparable接⼝


    ⾃定义实现⼀个过滤器


# Comparable接⼝

    约定

        如果是以自然顺序排序（从小到大）

            当 a<b 返回 负数
                >       正数
                =       0

        想从大到小排 则把约定反过来

    Predicate
        给定一个元素放回Boolean


# 内部类

• ⽤途：实现更加精细的封装
• 可以访问外围类的实例⽅法
• ⾮静态内部类
• 和⼀个外围类实例相绑定
• 可以访问外围类实例的⽅法
• 静态内部类
• 不和外围类实例相绑定
• 不可以访问外围实例的⽅法
• 原则：永远使⽤静态内部类，除⾮编译报错



匿名内部类
• 直接通过new的⽅式创建的⽆名类