
封装 隐藏细节

# 什么是封装

    封装 隐藏细节

    封装隐藏了内部实现细节，只暴露出接⼝
    
    电灯对象
        你只访问它的“开关”接⼝，不关⼼内部的“电路”细节
    汽⻋
        你只访问它的“⽅向盘”接⼝，不关⼼内部的细节


    低耦合  使得互相之间的联系很弱 只通过一个小的接口来通讯
    暴露出尽可能少的接口，使得内部细节实现需要改变的时候，使用该接口的情况不需要改变


# 不封装会怎么样？

    若很多人都在使用你写的程序，他们只能通过一个接口来访问
    需要对你内部实现做出改变的时候，对外的接口不需要改变 
    只要稍微改变细节，所有人都不需要改变

    暴露细节的结果就是⽆法变化（你变其他人也要变）

    软件的演进栗⼦：为原先的属性增加限制

    软件的演进栗⼦：修改某些属性


    让自己的改动不影响其他人
    对外的接口不变，其他人就不需要改变
    其他人是根据接口访问


# 封装的实现

    访问控制符

        public 任何⼈都能访问

        protected 只有⼦类可以访问和同⼀个包的可以访问

            包的一大作用

                区分同名类

                访问控制符

                    包可以提供一种边界，封装的边界
                    可以把实现的细节和对外的接口分离开
                    
                    外界不能访问包中的内容，但包中的类之间可以互相访问
[示意图](../png/包的隔离.png)
[示意图](../png/包的界限.png)

            包和包之间没有嵌套、包含关系

        package private （不加任何的访问限定符）只有同⼀个包的类可以访问

        private 只有⾃⼰可以访问


# javaBean约定

    getter

    setter


    对于javabean来说

    有一个非boolean值属性name 

        public String getName
        public void setName
    

    boolean

        isName
        setName



    json（序列化和反序列化的一种实现） 将对象用字符串方式表示出来的一种方法，把对象和字符相互转化

    如何把json字符串和java objec转换

    序列化

        对象是存在于内存中的 变成可以看见的字节流


        用声明的getter和setter当作属性的名字
        json读写的时候只看get set方法（达到封装的目的）

[JSON序列化/反序列化实战](https://github.com/hcsp/practise-json/pull/284)



# 设计模式实战：⼯⼚⽅法


    一套有助于提高软件可维护性 可扩展性的方法论


    使⽤静态⼯⼚⽅法代替构造器

        有名字，可以告诉你它在做什么

        不像构造器，不需要去创建一个新的对象

        可以返回当前声明类型的子类

        不需要每次都创建一个新的对象，返回一个已经预先定义好的对象

        根据当前环境 设置，加载未来才编写好的类


        不能被子类化，覆盖 

        不容易找到
    
    创建静态工厂方法的时候 要把原先的构造器私有化

        静态工厂方法表现的像是对外的接口，在该方法内使用构造器（完美实现封装，外界只通过一个接口）

[示意图](../png/静态工厂方法.png)

[工厂方法模式实战](https://github.com/hcsp/factory-method-pattern/pull/294)

# 类的访问限定符

    public 任何类都可以访问
    package private 同⼀个包的类可以访问（封装为内部的实现细节）
        包之间是没有⽗⼦关系的

    private inner class 只能在同⼀个类中访问
    

    ⽤中间类绕过包级私有的限制

        自己创建这个包，在这个包里访问同一个包的包级私有类（像bridge一样，连接包内外）
        在JVM看来他们没有区别，JVM看来包的限制 只限于包的名字（java.lang包不行）
[示意图](../png/bridge.png)
[绕过包级私有的限制](https://github.com/hcsp/bypass-package-private/pull/283)



封装的必要性——例⼦2
• 软件的演进——向外界暴露内部实现类的⻛险


# Java Platform Module System

    jdk8 最大的访问限定是包

    包只是一个文件夹，一个名字
    若想实现整个功能都封装在一起，只对外暴露一个接口（jdk8之前不行）

    jdk9 模块化，把很多个包封装成一个模块
    提供更大范围封装

扩展阅读
• JSON序列化/反序列化与JavaBean约定
• setter的链式调⽤

# 设计模式 builder模式

    很长的构造器带来的问题（参数太多）