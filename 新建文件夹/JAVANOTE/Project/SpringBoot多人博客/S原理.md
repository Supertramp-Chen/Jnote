SB 事实标准
    
    项目达到一定规模后 只有SB才能hold的住





若用java写一个web应用 如何请求解决业务逻辑的问题

    理论上可以写一个巨大无比的类

        里面处理all业务逻辑

        很多行


    结果

        在维护的时候就是一场灾难


        项目达到一定规模后 脑子处理巨大的代码就不够用了





    软件工程的重要职责

        职责分离

            把一个巨大的项目拆分成单一的模块

            每个模块只做一件事情

            模块和模块之间用接口来通讯（抽象的接口 对于业务逻辑的通讯）



        做一个项目 首先把其分成很多微小的模块 定义每个模块做的事情

            模块之间有依赖关系，模块内部有子模块

[示意图](../../png/eg架构图.png)


        一个一个不同的object，要让它工作 首先创建这个对象

        为对象起个高端的名字

            eg彩蛋

                class文件的十六进制表示开头都是cafebabe
                JVM用这个8个字节来区分一个文件是不是class文件

            java咖啡
            Bean咖啡豆，对象


        如UserService

            service名字是约定
            
            完成一项工作的对象 处理一件事情 —— 服务

            完成这个服务的对象 就叫服务的实例

        做一件事情的东西叫服务
        当A服务必须使用B服务才能完成自己的工作

            如OrderService 需使用 UserService里查询id的方法

            A依赖B 所以必须创建B服务才能创建A服务


            当服务过多的时候，不能再手动处理各服务之间的关系（依赖）




            spring扮演的角色 是个容器

                容器里有无数的bean，每个容器都是bean 可能依赖其他的bean（提供一个服务的对象）

                IOC容器

                    IOC控制反转

                    没有IOC容器的时候，你有几百个服务 互相之间有复杂的依赖关系
                    你必须把这些依赖关系理清楚，把它装配成满足要求的多个对象的集合

                        A依赖于B 意味B要先创建

                    要自己去把这些对象装配成完整的应用


                    有IOC容器

                        不需要去管谁先创建 谁后创建
                        创建这些关系
                        只需要告诉谁依赖于谁，不控制这些依赖关系，只是告诉它

                            容器会帮你装配好这一切，把控制权交给容器，容器帮你理清楚并装配好all bean


                
                DI依赖注入

                    如 bean A 依赖于 bean B

                    在容器里 spring把依赖的东西注入到里面去
                    容器帮你管理好具有依赖关系的对象之间的关系，帮你装配好



                对象之间的依赖关系很复杂，手动装配很麻烦，把控制权交给容器


                